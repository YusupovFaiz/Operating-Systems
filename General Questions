Общие вопросы:
1) Что такое ООП? – полное определение;
2) Магическое число 7 Миллера? – привести не менее 7 примеров из IT;
3) Энтропия ПО? – привести не менее 5 примеров нег энтропийных мер при разработке ПО;
4) 5 признаков сложной системы по Гради Бучу – по каждому признаку привести не менее 2-х пояснительных примером из Ваших Лабораторных работ или pet проектов;
5) Закон иерархических компенсаций Седова – привести не менее 5 исторических примеров применения закона Седова в эволюции IT сферы;

Ответы на общие вопросы:
1)ООП — парадигма программирования, основанная на концепции объектов, которые объединяют данные (поля/атрибуты) и методы (функции) для их обработки. Основные принципы:
Инкапсуляция – сокрытие внутренней реализации и защита данных.
Наследование – создание новых классов на основе существующих.
Полиморфизм – возможность объектов с одинаковым интерфейсом иметь разную реализацию.
Абстракция – выделение главных характеристик объекта, игнорируя детали.

2)Когнитивный предел: человек может одновременно удерживать в памяти 7±2 элемента.
Примеры из IT:
1. Лимит вкладок в браузере – большинство пользователей не держат открытыми >7-9 вкладок.
2. Меню навигации – сайты редко имеют >7 пунктов (например, GitHub: Pull requests, Issues, Marketplace и т.д.).
3. Аргументы функции – рекомендация не использовать >7 параметров (например, в Python def foo(a, b, c, d, e, f, g)).
4. Глубина иерархии папок – сложно ориентироваться при вложенности >7 уровней.
5. Число пунктов в CLI-интерфейсе (например, git --help показывает 7-10 основных команд).
6. Количество строк в функции – код становится сложнее для понимания при >7-10 строках.
7. Цветовая палитра UI – дизайнеры используют до 7 основных цветов (например, Material Design).

3) Определение: Мера хаоса в коде, ведущая к росту сложности поддержки.
Негэнтропийные меры (борьба с хаосом):
1. Рефакторинг – устранение "копипасты" (например, замена дублирующегося кода на функцию).
2. Инкапсуляция – сокрытие деталей реализации (например, приватные методы в классах).
3. Модульность – разбиение на компоненты (микросервисы вместо монолита).
4. Тестирование – автоматические тесты предотвращают "расползание" багов.
5. Документация – описание архитектуры снижает когнитивную нагрузку.

4)5 признаков сложной системы по Гради Бучу
1. Иерархичность
Пример 1: В API сервисе есть слои (контроллеры → сервисы → репозитории).
Пример 2: В игре объекты наследуются от базового класса GameEntity.
2. Эмерджентность (свойства системы ≠ сумме свойств частей)
Пример 1: База данных + кэш = высокая отказоустойчивость.
Пример 2: Микросервисы вместе дают функциональность, которую нельзя получить от одного сервиса.
3. Разделение ответственности
Пример 1: Отдельный класс Logger для логирования.
Пример 2: UserService не занимается отправкой email, а делегирует EmailService.
4. Неопределенность (поведение системы при ошибках)
Пример 1: Падение одного микросервиса не должно "ломать" всю систему.
Пример 2: Невалидный ввод в API должен обрабатываться gracefully (400 Bad Request).
5. Динамика (адаптация к изменениям)
Пример 1: Плагинная архитектура (например, в IDE можно добавить новые инструменты).
Пример 2: Feature flags для постепенного внедрения функциональности.

5) Закон иерархических компенсаций Седова
Суть: Рост сложности системы компенсируется созданием иерархических уровней управления.
Примеры из IT:
1. Переход от монолитов к микросервисам – вместо одного сложного приложения появились уровни (API-шлюзы, сервисы, базы данных).
2. Появление Docker/Kubernetes – управление сотнями серверов стало возможным за счет абстракций (контейнеры → кластеры).
3. Отказ от FTP в пользу Git – контроль версий создал новые уровни (ветки, пул-реквесты, CI/CD).
4. Развитие ОС – от простых диспетчеров задач до многоуровневых систем (драйверы → ядро → пользовательские процессы).
5. Эволюция сетей – от LAN к облачным архитектурам (VPC, CDN, балансировщики).
